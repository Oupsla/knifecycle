<!--
# This file is automatically generated by the `jsarch`
# module. Do not change it elsewhere, changes would
# be overriden.
-->
# Architecture Notes



## Knifecycle

The `knifecycle` project is intended to be a [dependency
 injection](https://en.wikipedia.org/wiki/Dependency_injection)
 and [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control)
 tool. It will always be tied to this goal since I prefer
 composing software instead of using frameworks.

It is designed to have a low footprint on services code.
 There is nothing worse than having to write specific code for
 a given tool. With `knifecycle`, services can be either constants,
 functions or object created synchronously or asynchronously. They
 can be reused elsewhere with no changes at all.

[See in context](./src/index.js#L24-L37)



### OOP

The `knifecycle` use case is one of the rare use case where
 [OOP](https://en.wikipedia.org/wiki/Object-oriented_programming)
 principles are a good fit.

A service provider is full of state since its concern is
 precisely to
 [encapsulate](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))
 your application global states.

[See in context](./src/index.js#L39-L48)



### One instance to rule them all

We almost never need to use several Knifecycle instances.
 This is why we are providing the `knifecycle/instance`
 module that give a direct access to a lazy instanciated
 `Knifecycle` instance.

At the same time, I prefer choosing when instantiating a
 singleton this is why I decided to not do it on the behalf
 of the developers by instead providing an opt-in interface
 to this singleton.

[See in context](./src/instance.js#L1-L12)



### Declaring services

The first step to use `knifecycle` is to declare
   services. There are three kinds of services:
  - constants: a constant is a simple value that will
   never change. It can be literal values, objects
   or even functions.
  - services: services are asynchronous functions
   resolving to objects, functions or complexer
   objects. Those one just need an initialization
   phase that must be done asynchronously.
  - providers: they are very similar to services
   except they have an additional layer of
   complexity. Indeed, they have to be hooked
   to the process life cycle to allow graceful
   shutdown of the applications build on top of
   `knifecycle`.

   In addition to this, services and providers can
    be declared as singletons. This means that they
    will be instanciated once for all for each
    executions silos using them (we will cover this
    topic later on).

[See in context](./src/index.js#L79-L102)



### Execution silos

Once all the services are declared, we need a way to bring
   them to life. Execution silos are where the magic happen.
   For each call of the `run` method with given dependencies,
   a new silo is created and the required environment to
   run the actual code is leveraged.

  Depending of your application design, you could run it
   in only one execution silo or into several ones
   according to the isolation level your wish to reach.

[See in context](./src/index.js#L368-L378)

